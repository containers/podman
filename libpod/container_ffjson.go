// Code generated by ffjson <https://github.com/pquerna/ffjson>. DO NOT EDIT.
// source: libpod/container.go

package libpod

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"github.com/containernetworking/cni/pkg/types"
	"github.com/containernetworking/cni/pkg/types/current"
	"github.com/cri-o/ocicni/pkg/ocicni"
	fflib "github.com/pquerna/ffjson/fflib/v1"
	"net"
	"reflect"
)

// MarshalJSON marshal bytes to json - template
func (j *ContainerConfig) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ContainerConfig) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	if j.Spec != nil {
		/* Struct fall back. type=specs.Spec kind=struct */
		buf.WriteString(`{ "spec":`)
		err = buf.Encode(j.Spec)
		if err != nil {
			return err
		}
	} else {
		buf.WriteString(`{ "spec":null`)
	}
	buf.WriteString(`,"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"name":`)
	fflib.WriteJsonString(buf, string(j.Name))
	buf.WriteByte(',')
	if len(j.Pod) != 0 {
		buf.WriteString(`"pod":`)
		fflib.WriteJsonString(buf, string(j.Pod))
		buf.WriteByte(',')
	}
	if len(j.RootfsImageID) != 0 {
		buf.WriteString(`"rootfsImageID":`)
		fflib.WriteJsonString(buf, string(j.RootfsImageID))
		buf.WriteByte(',')
	}
	if len(j.RootfsImageName) != 0 {
		buf.WriteString(`"rootfsImageName":`)
		fflib.WriteJsonString(buf, string(j.RootfsImageName))
		buf.WriteByte(',')
	}
	if j.ImageVolumes {
		buf.WriteString(`"imageVolumes":true`)
	} else {
		buf.WriteString(`"imageVolumes":false`)
	}
	buf.WriteByte(',')
	if len(j.ShmDir) != 0 {
		buf.WriteString(`"ShmDir":`)
		fflib.WriteJsonString(buf, string(j.ShmDir))
		buf.WriteByte(',')
	}
	buf.WriteString(`"shmSize":`)
	fflib.FormatBits2(buf, uint64(j.ShmSize), 10, j.ShmSize < 0)
	buf.WriteString(`,"staticDir":`)
	fflib.WriteJsonString(buf, string(j.StaticDir))
	buf.WriteByte(',')
	if len(j.Mounts) != 0 {
		buf.WriteString(`"mounts":`)
		if j.Mounts != nil {
			buf.WriteString(`[`)
			for i, v := range j.Mounts {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Privileged {
		buf.WriteString(`"privileged":true`)
	} else {
		buf.WriteString(`"privileged":false`)
	}
	buf.WriteByte(',')
	if len(j.ProcessLabel) != 0 {
		buf.WriteString(`"ProcessLabel":`)
		fflib.WriteJsonString(buf, string(j.ProcessLabel))
		buf.WriteByte(',')
	}
	if len(j.MountLabel) != 0 {
		buf.WriteString(`"MountLabel":`)
		fflib.WriteJsonString(buf, string(j.MountLabel))
		buf.WriteByte(',')
	}
	if len(j.User) != 0 {
		buf.WriteString(`"user":`)
		fflib.WriteJsonString(buf, string(j.User))
		buf.WriteByte(',')
	}
	if len(j.IPCNsCtr) != 0 {
		buf.WriteString(`"ipcNsCtr":`)
		fflib.WriteJsonString(buf, string(j.IPCNsCtr))
		buf.WriteByte(',')
	}
	if len(j.MountNsCtr) != 0 {
		buf.WriteString(`"mountNsCtr":`)
		fflib.WriteJsonString(buf, string(j.MountNsCtr))
		buf.WriteByte(',')
	}
	if len(j.NetNsCtr) != 0 {
		buf.WriteString(`"netNsCtr":`)
		fflib.WriteJsonString(buf, string(j.NetNsCtr))
		buf.WriteByte(',')
	}
	if len(j.PIDNsCtr) != 0 {
		buf.WriteString(`"pidNsCtr":`)
		fflib.WriteJsonString(buf, string(j.PIDNsCtr))
		buf.WriteByte(',')
	}
	if len(j.UserNsCtr) != 0 {
		buf.WriteString(`"userNsCtr":`)
		fflib.WriteJsonString(buf, string(j.UserNsCtr))
		buf.WriteByte(',')
	}
	if len(j.UTSNsCtr) != 0 {
		buf.WriteString(`"utsNsCtr":`)
		fflib.WriteJsonString(buf, string(j.UTSNsCtr))
		buf.WriteByte(',')
	}
	if len(j.CgroupNsCtr) != 0 {
		buf.WriteString(`"cgroupNsCtr":`)
		fflib.WriteJsonString(buf, string(j.CgroupNsCtr))
		buf.WriteByte(',')
	}
	if j.CreateNetNS {
		buf.WriteString(`"createNetNS":true`)
	} else {
		buf.WriteString(`"createNetNS":false`)
	}
	buf.WriteByte(',')
	if len(j.PortMappings) != 0 {
		buf.WriteString(`"portMappings":`)
		if j.PortMappings != nil {
			buf.WriteString(`[`)
			for i, v := range j.PortMappings {
				if i != 0 {
					buf.WriteString(`,`)
				}
				/* Struct fall back. type=ocicni.PortMapping kind=struct */
				err = buf.Encode(&v)
				if err != nil {
					return err
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.DNSServer) != 0 {
		buf.WriteString(`"dnsServer":`)
		if j.DNSServer != nil {
			buf.WriteString(`[`)
			for i, v := range j.DNSServer {
				if i != 0 {
					buf.WriteString(`,`)
				}
				if v != nil {
					buf.WriteString(`"`)
					{
						enc := base64.NewEncoder(base64.StdEncoding, buf)
						enc.Write(reflect.Indirect(reflect.ValueOf(v)).Bytes())
						enc.Close()
					}
					buf.WriteString(`"`)
				} else {
					buf.WriteString(`null`)
				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.DNSSearch) != 0 {
		buf.WriteString(`"dnsSearch":`)
		if j.DNSSearch != nil {
			buf.WriteString(`[`)
			for i, v := range j.DNSSearch {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.DNSOption) != 0 {
		buf.WriteString(`"dnsOption":`)
		if j.DNSOption != nil {
			buf.WriteString(`[`)
			for i, v := range j.DNSOption {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.HostAdd) != 0 {
		buf.WriteString(`"hostsAdd":`)
		if j.HostAdd != nil {
			buf.WriteString(`[`)
			for i, v := range j.HostAdd {
				if i != 0 {
					buf.WriteString(`,`)
				}
				fflib.WriteJsonString(buf, string(v))
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if j.Stdin != false {
		if j.Stdin {
			buf.WriteString(`"stdin":true`)
		} else {
			buf.WriteString(`"stdin":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.Labels) != 0 {
		if j.Labels == nil {
			buf.WriteString(`"labels":null`)
		} else {
			buf.WriteString(`"labels":{ `)
			for key, value := range j.Labels {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	if j.StopSignal != 0 {
		buf.WriteString(`"stopSignal":`)
		fflib.FormatBits2(buf, uint64(j.StopSignal), 10, false)
		buf.WriteByte(',')
	}
	if j.StopTimeout != 0 {
		buf.WriteString(`"stopTimeout":`)
		fflib.FormatBits2(buf, uint64(j.StopTimeout), 10, false)
		buf.WriteByte(',')
	}
	buf.WriteString(`"createdTime":`)

	{

		obj, err = j.CreatedTime.MarshalJSON()
		if err != nil {
			return err
		}
		buf.Write(obj)

	}
	buf.WriteString(`,"cgroupParent":`)
	fflib.WriteJsonString(buf, string(j.CgroupParent))
	buf.WriteString(`,"logPath":`)
	fflib.WriteJsonString(buf, string(j.LogPath))
	buf.WriteByte(',')
	if len(j.ConmonPidFile) != 0 {
		buf.WriteString(`"conmonPidFile":`)
		fflib.WriteJsonString(buf, string(j.ConmonPidFile))
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtContainerConfigbase = iota
	ffjtContainerConfignosuchkey

	ffjtContainerConfigSpec

	ffjtContainerConfigID

	ffjtContainerConfigName

	ffjtContainerConfigPod

	ffjtContainerConfigRootfsImageID

	ffjtContainerConfigRootfsImageName

	ffjtContainerConfigImageVolumes

	ffjtContainerConfigShmDir

	ffjtContainerConfigShmSize

	ffjtContainerConfigStaticDir

	ffjtContainerConfigMounts

	ffjtContainerConfigPrivileged

	ffjtContainerConfigProcessLabel

	ffjtContainerConfigMountLabel

	ffjtContainerConfigUser

	ffjtContainerConfigIPCNsCtr

	ffjtContainerConfigMountNsCtr

	ffjtContainerConfigNetNsCtr

	ffjtContainerConfigPIDNsCtr

	ffjtContainerConfigUserNsCtr

	ffjtContainerConfigUTSNsCtr

	ffjtContainerConfigCgroupNsCtr

	ffjtContainerConfigCreateNetNS

	ffjtContainerConfigPortMappings

	ffjtContainerConfigDNSServer

	ffjtContainerConfigDNSSearch

	ffjtContainerConfigDNSOption

	ffjtContainerConfigHostAdd

	ffjtContainerConfigStdin

	ffjtContainerConfigLabels

	ffjtContainerConfigStopSignal

	ffjtContainerConfigStopTimeout

	ffjtContainerConfigCreatedTime

	ffjtContainerConfigCgroupParent

	ffjtContainerConfigLogPath

	ffjtContainerConfigConmonPidFile
)

var ffjKeyContainerConfigSpec = []byte("spec")

var ffjKeyContainerConfigID = []byte("id")

var ffjKeyContainerConfigName = []byte("name")

var ffjKeyContainerConfigPod = []byte("pod")

var ffjKeyContainerConfigRootfsImageID = []byte("rootfsImageID")

var ffjKeyContainerConfigRootfsImageName = []byte("rootfsImageName")

var ffjKeyContainerConfigImageVolumes = []byte("imageVolumes")

var ffjKeyContainerConfigShmDir = []byte("ShmDir")

var ffjKeyContainerConfigShmSize = []byte("shmSize")

var ffjKeyContainerConfigStaticDir = []byte("staticDir")

var ffjKeyContainerConfigMounts = []byte("mounts")

var ffjKeyContainerConfigPrivileged = []byte("privileged")

var ffjKeyContainerConfigProcessLabel = []byte("ProcessLabel")

var ffjKeyContainerConfigMountLabel = []byte("MountLabel")

var ffjKeyContainerConfigUser = []byte("user")

var ffjKeyContainerConfigIPCNsCtr = []byte("ipcNsCtr")

var ffjKeyContainerConfigMountNsCtr = []byte("mountNsCtr")

var ffjKeyContainerConfigNetNsCtr = []byte("netNsCtr")

var ffjKeyContainerConfigPIDNsCtr = []byte("pidNsCtr")

var ffjKeyContainerConfigUserNsCtr = []byte("userNsCtr")

var ffjKeyContainerConfigUTSNsCtr = []byte("utsNsCtr")

var ffjKeyContainerConfigCgroupNsCtr = []byte("cgroupNsCtr")

var ffjKeyContainerConfigCreateNetNS = []byte("createNetNS")

var ffjKeyContainerConfigPortMappings = []byte("portMappings")

var ffjKeyContainerConfigDNSServer = []byte("dnsServer")

var ffjKeyContainerConfigDNSSearch = []byte("dnsSearch")

var ffjKeyContainerConfigDNSOption = []byte("dnsOption")

var ffjKeyContainerConfigHostAdd = []byte("hostsAdd")

var ffjKeyContainerConfigStdin = []byte("stdin")

var ffjKeyContainerConfigLabels = []byte("labels")

var ffjKeyContainerConfigStopSignal = []byte("stopSignal")

var ffjKeyContainerConfigStopTimeout = []byte("stopTimeout")

var ffjKeyContainerConfigCreatedTime = []byte("createdTime")

var ffjKeyContainerConfigCgroupParent = []byte("cgroupParent")

var ffjKeyContainerConfigLogPath = []byte("logPath")

var ffjKeyContainerConfigConmonPidFile = []byte("conmonPidFile")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ContainerConfig) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ContainerConfig) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtContainerConfigbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtContainerConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'M':

					if bytes.Equal(ffjKeyContainerConfigMountLabel, kn) {
						currentKey = ffjtContainerConfigMountLabel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'P':

					if bytes.Equal(ffjKeyContainerConfigProcessLabel, kn) {
						currentKey = ffjtContainerConfigProcessLabel
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'S':

					if bytes.Equal(ffjKeyContainerConfigShmDir, kn) {
						currentKey = ffjtContainerConfigShmDir
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeyContainerConfigCgroupNsCtr, kn) {
						currentKey = ffjtContainerConfigCgroupNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigCreateNetNS, kn) {
						currentKey = ffjtContainerConfigCreateNetNS
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigCreatedTime, kn) {
						currentKey = ffjtContainerConfigCreatedTime
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigCgroupParent, kn) {
						currentKey = ffjtContainerConfigCgroupParent
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigConmonPidFile, kn) {
						currentKey = ffjtContainerConfigConmonPidFile
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'd':

					if bytes.Equal(ffjKeyContainerConfigDNSServer, kn) {
						currentKey = ffjtContainerConfigDNSServer
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigDNSSearch, kn) {
						currentKey = ffjtContainerConfigDNSSearch
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigDNSOption, kn) {
						currentKey = ffjtContainerConfigDNSOption
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'h':

					if bytes.Equal(ffjKeyContainerConfigHostAdd, kn) {
						currentKey = ffjtContainerConfigHostAdd
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyContainerConfigID, kn) {
						currentKey = ffjtContainerConfigID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigImageVolumes, kn) {
						currentKey = ffjtContainerConfigImageVolumes
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigIPCNsCtr, kn) {
						currentKey = ffjtContainerConfigIPCNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'l':

					if bytes.Equal(ffjKeyContainerConfigLabels, kn) {
						currentKey = ffjtContainerConfigLabels
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigLogPath, kn) {
						currentKey = ffjtContainerConfigLogPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeyContainerConfigMounts, kn) {
						currentKey = ffjtContainerConfigMounts
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigMountNsCtr, kn) {
						currentKey = ffjtContainerConfigMountNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'n':

					if bytes.Equal(ffjKeyContainerConfigName, kn) {
						currentKey = ffjtContainerConfigName
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigNetNsCtr, kn) {
						currentKey = ffjtContainerConfigNetNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyContainerConfigPod, kn) {
						currentKey = ffjtContainerConfigPod
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigPrivileged, kn) {
						currentKey = ffjtContainerConfigPrivileged
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigPIDNsCtr, kn) {
						currentKey = ffjtContainerConfigPIDNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigPortMappings, kn) {
						currentKey = ffjtContainerConfigPortMappings
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeyContainerConfigRootfsImageID, kn) {
						currentKey = ffjtContainerConfigRootfsImageID
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigRootfsImageName, kn) {
						currentKey = ffjtContainerConfigRootfsImageName
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeyContainerConfigSpec, kn) {
						currentKey = ffjtContainerConfigSpec
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigShmSize, kn) {
						currentKey = ffjtContainerConfigShmSize
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigStaticDir, kn) {
						currentKey = ffjtContainerConfigStaticDir
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigStdin, kn) {
						currentKey = ffjtContainerConfigStdin
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigStopSignal, kn) {
						currentKey = ffjtContainerConfigStopSignal
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigStopTimeout, kn) {
						currentKey = ffjtContainerConfigStopTimeout
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'u':

					if bytes.Equal(ffjKeyContainerConfigUser, kn) {
						currentKey = ffjtContainerConfigUser
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigUserNsCtr, kn) {
						currentKey = ffjtContainerConfigUserNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeyContainerConfigUTSNsCtr, kn) {
						currentKey = ffjtContainerConfigUTSNsCtr
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigConmonPidFile, kn) {
					currentKey = ffjtContainerConfigConmonPidFile
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigLogPath, kn) {
					currentKey = ffjtContainerConfigLogPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigCgroupParent, kn) {
					currentKey = ffjtContainerConfigCgroupParent
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigCreatedTime, kn) {
					currentKey = ffjtContainerConfigCreatedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigStopTimeout, kn) {
					currentKey = ffjtContainerConfigStopTimeout
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigStopSignal, kn) {
					currentKey = ffjtContainerConfigStopSignal
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigLabels, kn) {
					currentKey = ffjtContainerConfigLabels
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigStdin, kn) {
					currentKey = ffjtContainerConfigStdin
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigHostAdd, kn) {
					currentKey = ffjtContainerConfigHostAdd
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigDNSOption, kn) {
					currentKey = ffjtContainerConfigDNSOption
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigDNSSearch, kn) {
					currentKey = ffjtContainerConfigDNSSearch
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigDNSServer, kn) {
					currentKey = ffjtContainerConfigDNSServer
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigPortMappings, kn) {
					currentKey = ffjtContainerConfigPortMappings
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigCreateNetNS, kn) {
					currentKey = ffjtContainerConfigCreateNetNS
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigCgroupNsCtr, kn) {
					currentKey = ffjtContainerConfigCgroupNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigUTSNsCtr, kn) {
					currentKey = ffjtContainerConfigUTSNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigUserNsCtr, kn) {
					currentKey = ffjtContainerConfigUserNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigPIDNsCtr, kn) {
					currentKey = ffjtContainerConfigPIDNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigNetNsCtr, kn) {
					currentKey = ffjtContainerConfigNetNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigMountNsCtr, kn) {
					currentKey = ffjtContainerConfigMountNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigIPCNsCtr, kn) {
					currentKey = ffjtContainerConfigIPCNsCtr
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigUser, kn) {
					currentKey = ffjtContainerConfigUser
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigMountLabel, kn) {
					currentKey = ffjtContainerConfigMountLabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigProcessLabel, kn) {
					currentKey = ffjtContainerConfigProcessLabel
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigPrivileged, kn) {
					currentKey = ffjtContainerConfigPrivileged
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigMounts, kn) {
					currentKey = ffjtContainerConfigMounts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigStaticDir, kn) {
					currentKey = ffjtContainerConfigStaticDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigShmSize, kn) {
					currentKey = ffjtContainerConfigShmSize
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigShmDir, kn) {
					currentKey = ffjtContainerConfigShmDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigImageVolumes, kn) {
					currentKey = ffjtContainerConfigImageVolumes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigRootfsImageName, kn) {
					currentKey = ffjtContainerConfigRootfsImageName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigRootfsImageID, kn) {
					currentKey = ffjtContainerConfigRootfsImageID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigPod, kn) {
					currentKey = ffjtContainerConfigPod
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigName, kn) {
					currentKey = ffjtContainerConfigName
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyContainerConfigID, kn) {
					currentKey = ffjtContainerConfigID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeyContainerConfigSpec, kn) {
					currentKey = ffjtContainerConfigSpec
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtContainerConfignosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtContainerConfigSpec:
					goto handle_Spec

				case ffjtContainerConfigID:
					goto handle_ID

				case ffjtContainerConfigName:
					goto handle_Name

				case ffjtContainerConfigPod:
					goto handle_Pod

				case ffjtContainerConfigRootfsImageID:
					goto handle_RootfsImageID

				case ffjtContainerConfigRootfsImageName:
					goto handle_RootfsImageName

				case ffjtContainerConfigImageVolumes:
					goto handle_ImageVolumes

				case ffjtContainerConfigShmDir:
					goto handle_ShmDir

				case ffjtContainerConfigShmSize:
					goto handle_ShmSize

				case ffjtContainerConfigStaticDir:
					goto handle_StaticDir

				case ffjtContainerConfigMounts:
					goto handle_Mounts

				case ffjtContainerConfigPrivileged:
					goto handle_Privileged

				case ffjtContainerConfigProcessLabel:
					goto handle_ProcessLabel

				case ffjtContainerConfigMountLabel:
					goto handle_MountLabel

				case ffjtContainerConfigUser:
					goto handle_User

				case ffjtContainerConfigIPCNsCtr:
					goto handle_IPCNsCtr

				case ffjtContainerConfigMountNsCtr:
					goto handle_MountNsCtr

				case ffjtContainerConfigNetNsCtr:
					goto handle_NetNsCtr

				case ffjtContainerConfigPIDNsCtr:
					goto handle_PIDNsCtr

				case ffjtContainerConfigUserNsCtr:
					goto handle_UserNsCtr

				case ffjtContainerConfigUTSNsCtr:
					goto handle_UTSNsCtr

				case ffjtContainerConfigCgroupNsCtr:
					goto handle_CgroupNsCtr

				case ffjtContainerConfigCreateNetNS:
					goto handle_CreateNetNS

				case ffjtContainerConfigPortMappings:
					goto handle_PortMappings

				case ffjtContainerConfigDNSServer:
					goto handle_DNSServer

				case ffjtContainerConfigDNSSearch:
					goto handle_DNSSearch

				case ffjtContainerConfigDNSOption:
					goto handle_DNSOption

				case ffjtContainerConfigHostAdd:
					goto handle_HostAdd

				case ffjtContainerConfigStdin:
					goto handle_Stdin

				case ffjtContainerConfigLabels:
					goto handle_Labels

				case ffjtContainerConfigStopSignal:
					goto handle_StopSignal

				case ffjtContainerConfigStopTimeout:
					goto handle_StopTimeout

				case ffjtContainerConfigCreatedTime:
					goto handle_CreatedTime

				case ffjtContainerConfigCgroupParent:
					goto handle_CgroupParent

				case ffjtContainerConfigLogPath:
					goto handle_LogPath

				case ffjtContainerConfigConmonPidFile:
					goto handle_ConmonPidFile

				case ffjtContainerConfignosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_Spec:

	/* handler: j.Spec type=specs.Spec kind=struct quoted=false*/

	{
		/* Falling back. type=specs.Spec kind=struct */
		tbuf, err := fs.CaptureField(tok)
		if err != nil {
			return fs.WrapErr(err)
		}

		err = json.Unmarshal(tbuf, &j.Spec)
		if err != nil {
			return fs.WrapErr(err)
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Name:

	/* handler: j.Name type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Name = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Pod:

	/* handler: j.Pod type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Pod = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RootfsImageID:

	/* handler: j.RootfsImageID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RootfsImageID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RootfsImageName:

	/* handler: j.RootfsImageName type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RootfsImageName = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ImageVolumes:

	/* handler: j.ImageVolumes type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.ImageVolumes = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.ImageVolumes = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShmDir:

	/* handler: j.ShmDir type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ShmDir = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ShmSize:

	/* handler: j.ShmSize type=int64 kind=int64 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int64", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ShmSize = int64(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StaticDir:

	/* handler: j.StaticDir type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.StaticDir = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mounts:

	/* handler: j.Mounts type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Mounts = nil
		} else {

			j.Mounts = []string{}

			wantVal := true

			for {

				var tmpJMounts string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJMounts type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJMounts = string(string(outBuf))

					}
				}

				j.Mounts = append(j.Mounts, tmpJMounts)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Privileged:

	/* handler: j.Privileged type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Privileged = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Privileged = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ProcessLabel:

	/* handler: j.ProcessLabel type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ProcessLabel = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MountLabel:

	/* handler: j.MountLabel type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MountLabel = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_User:

	/* handler: j.User type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.User = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IPCNsCtr:

	/* handler: j.IPCNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.IPCNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_MountNsCtr:

	/* handler: j.MountNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.MountNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_NetNsCtr:

	/* handler: j.NetNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.NetNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PIDNsCtr:

	/* handler: j.PIDNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.PIDNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UserNsCtr:

	/* handler: j.UserNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UserNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_UTSNsCtr:

	/* handler: j.UTSNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.UTSNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CgroupNsCtr:

	/* handler: j.CgroupNsCtr type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CgroupNsCtr = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreateNetNS:

	/* handler: j.CreateNetNS type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.CreateNetNS = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.CreateNetNS = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PortMappings:

	/* handler: j.PortMappings type=[]ocicni.PortMapping kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.PortMappings = nil
		} else {

			j.PortMappings = []ocicni.PortMapping{}

			wantVal := true

			for {

				var tmpJPortMappings ocicni.PortMapping

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJPortMappings type=ocicni.PortMapping kind=struct quoted=false*/

				{
					/* Falling back. type=ocicni.PortMapping kind=struct */
					tbuf, err := fs.CaptureField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}

					err = json.Unmarshal(tbuf, &tmpJPortMappings)
					if err != nil {
						return fs.WrapErr(err)
					}
				}

				j.PortMappings = append(j.PortMappings, tmpJPortMappings)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DNSServer:

	/* handler: j.DNSServer type=[]net.IP kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.DNSServer = nil
		} else {

			j.DNSServer = []net.IP{}

			wantVal := true

			for {

				var tmpJDNSServer net.IP

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDNSServer type=net.IP kind=slice quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for IP", tok))
						}
					}

					if tok == fflib.FFTok_null {
						tmpJDNSServer = nil
					} else {
						b := make([]byte, base64.StdEncoding.DecodedLen(fs.Output.Len()))
						n, err := base64.StdEncoding.Decode(b, fs.Output.Bytes())
						if err != nil {
							return fs.WrapErr(err)
						}

						v := reflect.ValueOf(&tmpJDNSServer).Elem()
						v.SetBytes(b[0:n])

					}
				}

				j.DNSServer = append(j.DNSServer, tmpJDNSServer)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DNSSearch:

	/* handler: j.DNSSearch type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.DNSSearch = nil
		} else {

			j.DNSSearch = []string{}

			wantVal := true

			for {

				var tmpJDNSSearch string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDNSSearch type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJDNSSearch = string(string(outBuf))

					}
				}

				j.DNSSearch = append(j.DNSSearch, tmpJDNSSearch)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_DNSOption:

	/* handler: j.DNSOption type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.DNSOption = nil
		} else {

			j.DNSOption = []string{}

			wantVal := true

			for {

				var tmpJDNSOption string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJDNSOption type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJDNSOption = string(string(outBuf))

					}
				}

				j.DNSOption = append(j.DNSOption, tmpJDNSOption)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_HostAdd:

	/* handler: j.HostAdd type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.HostAdd = nil
		} else {

			j.HostAdd = []string{}

			wantVal := true

			for {

				var tmpJHostAdd string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJHostAdd type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJHostAdd = string(string(outBuf))

					}
				}

				j.HostAdd = append(j.HostAdd, tmpJHostAdd)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Stdin:

	/* handler: j.Stdin type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Stdin = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Stdin = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Labels:

	/* handler: j.Labels type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Labels = nil
		} else {

			j.Labels = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJLabels string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJLabels type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJLabels = string(string(outBuf))

					}
				}

				j.Labels[k] = tmpJLabels

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StopSignal:

	/* handler: j.StopSignal type=uint kind=uint quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StopSignal = uint(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StopTimeout:

	/* handler: j.StopTimeout type=uint kind=uint quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for uint", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseUint(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.StopTimeout = uint(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CreatedTime:

	/* handler: j.CreatedTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.CreatedTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_CgroupParent:

	/* handler: j.CgroupParent type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.CgroupParent = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_LogPath:

	/* handler: j.LogPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.LogPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConmonPidFile:

	/* handler: j.ConmonPidFile type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ConmonPidFile = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *ExecSession) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *ExecSession) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{"id":`)
	fflib.WriteJsonString(buf, string(j.ID))
	buf.WriteString(`,"command":`)
	if j.Command != nil {
		buf.WriteString(`[`)
		for i, v := range j.Command {
			if i != 0 {
				buf.WriteString(`,`)
			}
			fflib.WriteJsonString(buf, string(v))
		}
		buf.WriteString(`]`)
	} else {
		buf.WriteString(`null`)
	}
	buf.WriteString(`,"pid":`)
	fflib.FormatBits2(buf, uint64(j.PID), 10, j.PID < 0)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtExecSessionbase = iota
	ffjtExecSessionnosuchkey

	ffjtExecSessionID

	ffjtExecSessionCommand

	ffjtExecSessionPID
)

var ffjKeyExecSessionID = []byte("id")

var ffjKeyExecSessionCommand = []byte("command")

var ffjKeyExecSessionPID = []byte("pid")

// UnmarshalJSON umarshall json - template of ffjson
func (j *ExecSession) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *ExecSession) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtExecSessionbase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtExecSessionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'c':

					if bytes.Equal(ffjKeyExecSessionCommand, kn) {
						currentKey = ffjtExecSessionCommand
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeyExecSessionID, kn) {
						currentKey = ffjtExecSessionID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeyExecSessionPID, kn) {
						currentKey = ffjtExecSessionPID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.SimpleLetterEqualFold(ffjKeyExecSessionPID, kn) {
					currentKey = ffjtExecSessionPID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyExecSessionCommand, kn) {
					currentKey = ffjtExecSessionCommand
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeyExecSessionID, kn) {
					currentKey = ffjtExecSessionID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtExecSessionnosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtExecSessionID:
					goto handle_ID

				case ffjtExecSessionCommand:
					goto handle_Command

				case ffjtExecSessionPID:
					goto handle_PID

				case ffjtExecSessionnosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_ID:

	/* handler: j.ID type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ID = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Command:

	/* handler: j.Command type=[]string kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Command = nil
		} else {

			j.Command = []string{}

			wantVal := true

			for {

				var tmpJCommand string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJCommand type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJCommand = string(string(outBuf))

					}
				}

				j.Command = append(j.Command, tmpJCommand)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PID:

	/* handler: j.PID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}

// MarshalJSON marshal bytes to json - template
func (j *containerState) MarshalJSON() ([]byte, error) {
	var buf fflib.Buffer
	if j == nil {
		buf.WriteString("null")
		return buf.Bytes(), nil
	}
	err := j.MarshalJSONBuf(&buf)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}

// MarshalJSONBuf marshal buff to json - template
func (j *containerState) MarshalJSONBuf(buf fflib.EncodingBuffer) error {
	if j == nil {
		buf.WriteString("null")
		return nil
	}
	var err error
	var obj []byte
	_ = obj
	_ = err
	buf.WriteString(`{ "state":`)
	fflib.FormatBits2(buf, uint64(j.State), 10, j.State < 0)
	buf.WriteByte(',')
	if len(j.ConfigPath) != 0 {
		buf.WriteString(`"configPath":`)
		fflib.WriteJsonString(buf, string(j.ConfigPath))
		buf.WriteByte(',')
	}
	if len(j.RunDir) != 0 {
		buf.WriteString(`"runDir":`)
		fflib.WriteJsonString(buf, string(j.RunDir))
		buf.WriteByte(',')
	}
	if j.Mounted != false {
		if j.Mounted {
			buf.WriteString(`"mounted":true`)
		} else {
			buf.WriteString(`"mounted":false`)
		}
		buf.WriteByte(',')
	}
	if len(j.Mountpoint) != 0 {
		buf.WriteString(`"mountPoint":`)
		fflib.WriteJsonString(buf, string(j.Mountpoint))
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"startedTime":`)

		{

			obj, err = j.StartedTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if true {
		buf.WriteString(`"finishedTime":`)

		{

			obj, err = j.FinishedTime.MarshalJSON()
			if err != nil {
				return err
			}
			buf.Write(obj)

		}
		buf.WriteByte(',')
	}
	if j.ExitCode != 0 {
		buf.WriteString(`"exitCode":`)
		fflib.FormatBits2(buf, uint64(j.ExitCode), 10, j.ExitCode < 0)
		buf.WriteByte(',')
	}
	if j.OOMKilled != false {
		if j.OOMKilled {
			buf.WriteString(`"oomKilled":true`)
		} else {
			buf.WriteString(`"oomKilled":false`)
		}
		buf.WriteByte(',')
	}
	if j.PID != 0 {
		buf.WriteString(`"pid":`)
		fflib.FormatBits2(buf, uint64(j.PID), 10, j.PID < 0)
		buf.WriteByte(',')
	}
	if len(j.ExecSessions) != 0 {
		buf.WriteString(`"execSessions":`)
		/* Falling back. type=map[string]*libpod.ExecSession kind=map */
		err = buf.Encode(j.ExecSessions)
		if err != nil {
			return err
		}
		buf.WriteByte(',')
	}
	if len(j.IPs) != 0 {
		buf.WriteString(`"ipAddresses":`)
		if j.IPs != nil {
			buf.WriteString(`[`)
			for i, v := range j.IPs {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						obj, err = v.MarshalJSON()
						if err != nil {
							return err
						}
						buf.Write(obj)

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.Routes) != 0 {
		buf.WriteString(`"routes":`)
		if j.Routes != nil {
			buf.WriteString(`[`)
			for i, v := range j.Routes {
				if i != 0 {
					buf.WriteString(`,`)
				}

				{

					if v == nil {
						buf.WriteString("null")
					} else {

						obj, err = v.MarshalJSON()
						if err != nil {
							return err
						}
						buf.Write(obj)

					}

				}
			}
			buf.WriteString(`]`)
		} else {
			buf.WriteString(`null`)
		}
		buf.WriteByte(',')
	}
	if len(j.BindMounts) != 0 {
		if j.BindMounts == nil {
			buf.WriteString(`"bindMounts":null`)
		} else {
			buf.WriteString(`"bindMounts":{ `)
			for key, value := range j.BindMounts {
				fflib.WriteJsonString(buf, key)
				buf.WriteString(`:`)
				fflib.WriteJsonString(buf, string(value))
				buf.WriteByte(',')
			}
			buf.Rewind(1)
			buf.WriteByte('}')
		}
		buf.WriteByte(',')
	}
	buf.Rewind(1)
	buf.WriteByte('}')
	return nil
}

const (
	ffjtcontainerStatebase = iota
	ffjtcontainerStatenosuchkey

	ffjtcontainerStateState

	ffjtcontainerStateConfigPath

	ffjtcontainerStateRunDir

	ffjtcontainerStateMounted

	ffjtcontainerStateMountpoint

	ffjtcontainerStateStartedTime

	ffjtcontainerStateFinishedTime

	ffjtcontainerStateExitCode

	ffjtcontainerStateOOMKilled

	ffjtcontainerStatePID

	ffjtcontainerStateExecSessions

	ffjtcontainerStateIPs

	ffjtcontainerStateRoutes

	ffjtcontainerStateBindMounts
)

var ffjKeycontainerStateState = []byte("state")

var ffjKeycontainerStateConfigPath = []byte("configPath")

var ffjKeycontainerStateRunDir = []byte("runDir")

var ffjKeycontainerStateMounted = []byte("mounted")

var ffjKeycontainerStateMountpoint = []byte("mountPoint")

var ffjKeycontainerStateStartedTime = []byte("startedTime")

var ffjKeycontainerStateFinishedTime = []byte("finishedTime")

var ffjKeycontainerStateExitCode = []byte("exitCode")

var ffjKeycontainerStateOOMKilled = []byte("oomKilled")

var ffjKeycontainerStatePID = []byte("pid")

var ffjKeycontainerStateExecSessions = []byte("execSessions")

var ffjKeycontainerStateIPs = []byte("ipAddresses")

var ffjKeycontainerStateRoutes = []byte("routes")

var ffjKeycontainerStateBindMounts = []byte("bindMounts")

// UnmarshalJSON umarshall json - template of ffjson
func (j *containerState) UnmarshalJSON(input []byte) error {
	fs := fflib.NewFFLexer(input)
	return j.UnmarshalJSONFFLexer(fs, fflib.FFParse_map_start)
}

// UnmarshalJSONFFLexer fast json unmarshall - template ffjson
func (j *containerState) UnmarshalJSONFFLexer(fs *fflib.FFLexer, state fflib.FFParseState) error {
	var err error
	currentKey := ffjtcontainerStatebase
	_ = currentKey
	tok := fflib.FFTok_init
	wantedTok := fflib.FFTok_init

mainparse:
	for {
		tok = fs.Scan()
		//	println(fmt.Sprintf("debug: tok: %v  state: %v", tok, state))
		if tok == fflib.FFTok_error {
			goto tokerror
		}

		switch state {

		case fflib.FFParse_map_start:
			if tok != fflib.FFTok_left_bracket {
				wantedTok = fflib.FFTok_left_bracket
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_key
			continue

		case fflib.FFParse_after_value:
			if tok == fflib.FFTok_comma {
				state = fflib.FFParse_want_key
			} else if tok == fflib.FFTok_right_bracket {
				goto done
			} else {
				wantedTok = fflib.FFTok_comma
				goto wrongtokenerror
			}

		case fflib.FFParse_want_key:
			// json {} ended. goto exit. woo.
			if tok == fflib.FFTok_right_bracket {
				goto done
			}
			if tok != fflib.FFTok_string {
				wantedTok = fflib.FFTok_string
				goto wrongtokenerror
			}

			kn := fs.Output.Bytes()
			if len(kn) <= 0 {
				// "" case. hrm.
				currentKey = ffjtcontainerStatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			} else {
				switch kn[0] {

				case 'b':

					if bytes.Equal(ffjKeycontainerStateBindMounts, kn) {
						currentKey = ffjtcontainerStateBindMounts
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'c':

					if bytes.Equal(ffjKeycontainerStateConfigPath, kn) {
						currentKey = ffjtcontainerStateConfigPath
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'e':

					if bytes.Equal(ffjKeycontainerStateExitCode, kn) {
						currentKey = ffjtcontainerStateExitCode
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateExecSessions, kn) {
						currentKey = ffjtcontainerStateExecSessions
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'f':

					if bytes.Equal(ffjKeycontainerStateFinishedTime, kn) {
						currentKey = ffjtcontainerStateFinishedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'i':

					if bytes.Equal(ffjKeycontainerStateIPs, kn) {
						currentKey = ffjtcontainerStateIPs
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'm':

					if bytes.Equal(ffjKeycontainerStateMounted, kn) {
						currentKey = ffjtcontainerStateMounted
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateMountpoint, kn) {
						currentKey = ffjtcontainerStateMountpoint
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'o':

					if bytes.Equal(ffjKeycontainerStateOOMKilled, kn) {
						currentKey = ffjtcontainerStateOOMKilled
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'p':

					if bytes.Equal(ffjKeycontainerStatePID, kn) {
						currentKey = ffjtcontainerStatePID
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 'r':

					if bytes.Equal(ffjKeycontainerStateRunDir, kn) {
						currentKey = ffjtcontainerStateRunDir
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateRoutes, kn) {
						currentKey = ffjtcontainerStateRoutes
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				case 's':

					if bytes.Equal(ffjKeycontainerStateState, kn) {
						currentKey = ffjtcontainerStateState
						state = fflib.FFParse_want_colon
						goto mainparse

					} else if bytes.Equal(ffjKeycontainerStateStartedTime, kn) {
						currentKey = ffjtcontainerStateStartedTime
						state = fflib.FFParse_want_colon
						goto mainparse
					}

				}

				if fflib.EqualFoldRight(ffjKeycontainerStateBindMounts, kn) {
					currentKey = ffjtcontainerStateBindMounts
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateRoutes, kn) {
					currentKey = ffjtcontainerStateRoutes
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateIPs, kn) {
					currentKey = ffjtcontainerStateIPs
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateExecSessions, kn) {
					currentKey = ffjtcontainerStateExecSessions
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStatePID, kn) {
					currentKey = ffjtcontainerStatePID
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateOOMKilled, kn) {
					currentKey = ffjtcontainerStateOOMKilled
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateExitCode, kn) {
					currentKey = ffjtcontainerStateExitCode
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateFinishedTime, kn) {
					currentKey = ffjtcontainerStateFinishedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateStartedTime, kn) {
					currentKey = ffjtcontainerStateStartedTime
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateMountpoint, kn) {
					currentKey = ffjtcontainerStateMountpoint
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateMounted, kn) {
					currentKey = ffjtcontainerStateMounted
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateRunDir, kn) {
					currentKey = ffjtcontainerStateRunDir
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.SimpleLetterEqualFold(ffjKeycontainerStateConfigPath, kn) {
					currentKey = ffjtcontainerStateConfigPath
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				if fflib.EqualFoldRight(ffjKeycontainerStateState, kn) {
					currentKey = ffjtcontainerStateState
					state = fflib.FFParse_want_colon
					goto mainparse
				}

				currentKey = ffjtcontainerStatenosuchkey
				state = fflib.FFParse_want_colon
				goto mainparse
			}

		case fflib.FFParse_want_colon:
			if tok != fflib.FFTok_colon {
				wantedTok = fflib.FFTok_colon
				goto wrongtokenerror
			}
			state = fflib.FFParse_want_value
			continue
		case fflib.FFParse_want_value:

			if tok == fflib.FFTok_left_brace || tok == fflib.FFTok_left_bracket || tok == fflib.FFTok_integer || tok == fflib.FFTok_double || tok == fflib.FFTok_string || tok == fflib.FFTok_bool || tok == fflib.FFTok_null {
				switch currentKey {

				case ffjtcontainerStateState:
					goto handle_State

				case ffjtcontainerStateConfigPath:
					goto handle_ConfigPath

				case ffjtcontainerStateRunDir:
					goto handle_RunDir

				case ffjtcontainerStateMounted:
					goto handle_Mounted

				case ffjtcontainerStateMountpoint:
					goto handle_Mountpoint

				case ffjtcontainerStateStartedTime:
					goto handle_StartedTime

				case ffjtcontainerStateFinishedTime:
					goto handle_FinishedTime

				case ffjtcontainerStateExitCode:
					goto handle_ExitCode

				case ffjtcontainerStateOOMKilled:
					goto handle_OOMKilled

				case ffjtcontainerStatePID:
					goto handle_PID

				case ffjtcontainerStateExecSessions:
					goto handle_ExecSessions

				case ffjtcontainerStateIPs:
					goto handle_IPs

				case ffjtcontainerStateRoutes:
					goto handle_Routes

				case ffjtcontainerStateBindMounts:
					goto handle_BindMounts

				case ffjtcontainerStatenosuchkey:
					err = fs.SkipField(tok)
					if err != nil {
						return fs.WrapErr(err)
					}
					state = fflib.FFParse_after_value
					goto mainparse
				}
			} else {
				goto wantedvalue
			}
		}
	}

handle_State:

	/* handler: j.State type=libpod.ContainerStatus kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ContainerStatus", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.State = ContainerStatus(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ConfigPath:

	/* handler: j.ConfigPath type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.ConfigPath = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_RunDir:

	/* handler: j.RunDir type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.RunDir = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mounted:

	/* handler: j.Mounted type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.Mounted = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.Mounted = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Mountpoint:

	/* handler: j.Mountpoint type=string kind=string quoted=false*/

	{

		{
			if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
			}
		}

		if tok == fflib.FFTok_null {

		} else {

			outBuf := fs.Output.Bytes()

			j.Mountpoint = string(string(outBuf))

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_StartedTime:

	/* handler: j.StartedTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.StartedTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_FinishedTime:

	/* handler: j.FinishedTime type=time.Time kind=struct quoted=false*/

	{
		if tok == fflib.FFTok_null {

		} else {

			tbuf, err := fs.CaptureField(tok)
			if err != nil {
				return fs.WrapErr(err)
			}

			err = j.FinishedTime.UnmarshalJSON(tbuf)
			if err != nil {
				return fs.WrapErr(err)
			}
		}
		state = fflib.FFParse_after_value
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExitCode:

	/* handler: j.ExitCode type=int32 kind=int32 quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int32", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 32)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.ExitCode = int32(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_OOMKilled:

	/* handler: j.OOMKilled type=bool kind=bool quoted=false*/

	{
		if tok != fflib.FFTok_bool && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for bool", tok))
		}
	}

	{
		if tok == fflib.FFTok_null {

		} else {
			tmpb := fs.Output.Bytes()

			if bytes.Compare([]byte{'t', 'r', 'u', 'e'}, tmpb) == 0 {

				j.OOMKilled = true

			} else if bytes.Compare([]byte{'f', 'a', 'l', 's', 'e'}, tmpb) == 0 {

				j.OOMKilled = false

			} else {
				err = errors.New("unexpected bytes for true/false value")
				return fs.WrapErr(err)
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_PID:

	/* handler: j.PID type=int kind=int quoted=false*/

	{
		if tok != fflib.FFTok_integer && tok != fflib.FFTok_null {
			return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for int", tok))
		}
	}

	{

		if tok == fflib.FFTok_null {

		} else {

			tval, err := fflib.ParseInt(fs.Output.Bytes(), 10, 64)

			if err != nil {
				return fs.WrapErr(err)
			}

			j.PID = int(tval)

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_ExecSessions:

	/* handler: j.ExecSessions type=map[string]*libpod.ExecSession kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.ExecSessions = nil
		} else {

			j.ExecSessions = make(map[string]*ExecSession, 0)

			wantVal := true

			for {

				var k string

				var tmpJExecSessions *ExecSession

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJExecSessions type=*libpod.ExecSession kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

						tmpJExecSessions = nil

					} else {

						if tmpJExecSessions == nil {
							tmpJExecSessions = new(ExecSession)
						}

						err = tmpJExecSessions.UnmarshalJSONFFLexer(fs, fflib.FFParse_want_key)
						if err != nil {
							return err
						}
					}
					state = fflib.FFParse_after_value
				}

				j.ExecSessions[k] = tmpJExecSessions

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_IPs:

	/* handler: j.IPs type=[]*current.IPConfig kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.IPs = nil
		} else {

			j.IPs = []*current.IPConfig{}

			wantVal := true

			for {

				var tmpJIPs *current.IPConfig

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJIPs type=*current.IPConfig kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJIPs.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.IPs = append(j.IPs, tmpJIPs)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_Routes:

	/* handler: j.Routes type=[]*types.Route kind=slice quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_brace && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.Routes = nil
		} else {

			j.Routes = []*types.Route{}

			wantVal := true

			for {

				var tmpJRoutes *types.Route

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_brace {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: tmpJRoutes type=*types.Route kind=ptr quoted=false*/

				{
					if tok == fflib.FFTok_null {

					} else {

						tbuf, err := fs.CaptureField(tok)
						if err != nil {
							return fs.WrapErr(err)
						}

						err = tmpJRoutes.UnmarshalJSON(tbuf)
						if err != nil {
							return fs.WrapErr(err)
						}
					}
					state = fflib.FFParse_after_value
				}

				j.Routes = append(j.Routes, tmpJRoutes)

				wantVal = false
			}
		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

handle_BindMounts:

	/* handler: j.BindMounts type=map[string]string kind=map quoted=false*/

	{

		{
			if tok != fflib.FFTok_left_bracket && tok != fflib.FFTok_null {
				return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for ", tok))
			}
		}

		if tok == fflib.FFTok_null {
			j.BindMounts = nil
		} else {

			j.BindMounts = make(map[string]string, 0)

			wantVal := true

			for {

				var k string

				var tmpJBindMounts string

				tok = fs.Scan()
				if tok == fflib.FFTok_error {
					goto tokerror
				}
				if tok == fflib.FFTok_right_bracket {
					break
				}

				if tok == fflib.FFTok_comma {
					if wantVal == true {
						// TODO(pquerna): this isn't an ideal error message, this handles
						// things like [,,,] as an array value.
						return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
					}
					continue
				} else {
					wantVal = true
				}

				/* handler: k type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						k = string(string(outBuf))

					}
				}

				// Expect ':' after key
				tok = fs.Scan()
				if tok != fflib.FFTok_colon {
					return fs.WrapErr(fmt.Errorf("wanted colon token, but got token: %v", tok))
				}

				tok = fs.Scan()
				/* handler: tmpJBindMounts type=string kind=string quoted=false*/

				{

					{
						if tok != fflib.FFTok_string && tok != fflib.FFTok_null {
							return fs.WrapErr(fmt.Errorf("cannot unmarshal %s into Go value for string", tok))
						}
					}

					if tok == fflib.FFTok_null {

					} else {

						outBuf := fs.Output.Bytes()

						tmpJBindMounts = string(string(outBuf))

					}
				}

				j.BindMounts[k] = tmpJBindMounts

				wantVal = false
			}

		}
	}

	state = fflib.FFParse_after_value
	goto mainparse

wantedvalue:
	return fs.WrapErr(fmt.Errorf("wanted value token, but got token: %v", tok))
wrongtokenerror:
	return fs.WrapErr(fmt.Errorf("ffjson: wanted token: %v, but got token: %v output=%s", wantedTok, tok, fs.Output.String()))
tokerror:
	if fs.BigError != nil {
		return fs.WrapErr(fs.BigError)
	}
	err = fs.Error.ToError()
	if err != nil {
		return fs.WrapErr(err)
	}
	panic("ffjson-generated: unreachable, please report bug.")
done:

	return nil
}
