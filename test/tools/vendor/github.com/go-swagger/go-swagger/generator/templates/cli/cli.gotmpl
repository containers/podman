// Code generated by go-swagger; DO NOT EDIT.

{{ if .Copyright -}}// {{ comment .Copyright -}}{{ end }}

package {{ .GenOpts.CliPackage }}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "log"
  "os"
  "path"
  "path/filepath"

  httptransport "github.com/go-openapi/runtime/client"
  "github.com/spf13/cobra"
  "github.com/spf13/viper"
  {{ imports .DefaultImports }}
  {{ imports .Imports }}
)

var (
  // debug flag indicating that cli should output debug logs
  debug bool

  // config file location
  configFile string

  // dry run flag
  dryRun bool

  // name of the executable
  exeName = filepath.Base(os.Args[0])
)

// logDebugf writes debug log to stdout
func logDebugf(format string, v ...interface{}) {
  if !debug{
    return
  }
  log.Printf(format, v...)
}

{{/*TODO: make this a swagger cli option*/}}
// depth of recursion to construct model flags
var maxDepth int = 5

// makeClient constructs a client object
func makeClient(cmd *cobra.Command, _ []string) (*client.{{ pascalize .Name }}, error) {
  hostname := viper.GetString("hostname")
  viper.SetDefault("base_path", client.DefaultBasePath)
  basePath := viper.GetString("base_path")
  scheme := viper.GetString("scheme")

  r := httptransport.New(hostname, basePath, []string{scheme})
  r.SetDebug(debug)

  {{- /* user might define custom mediatype xxx/json and there is no registered ones to handle. */}}
  // set custom producer and consumer to use the default ones
  {{ range .Consumes }}
    {{ range .AllSerializers }}
      {{- if stringContains .MediaType "json" }}
  r.Consumers["{{ .MediaType }}"] = runtime.JSONConsumer()
      {{- else }}
  // warning: consumes {{ .MediaType }} is not supported by go-swagger cli yet
      {{- end }}
    {{- end }}
  {{ end }}
  {{ range .Produces }}
    {{- range .AllSerializers }}
      {{- if stringContains .MediaType "json" }}
  r.Producers["{{ .MediaType }}"] = runtime.JSONProducer()
      {{- else }}
  // warning: produces {{ .MediaType }} is not supported by go-swagger cli yet
      {{- end }}
    {{- end }}
  {{- end }}

  {{- if .SecurityDefinitions }}

  auth, err := makeAuthInfoWriter(cmd)
  if err != nil {
  return nil, err
  }
  r.DefaultAuthentication = auth
  {{- end }}

  appCli := client.New(r, strfmt.Default)
  logDebugf("Server url: %v://%v", scheme, hostname)

  return appCli, nil
}

// MakeRootCmd returns the root cmd
func MakeRootCmd() (*cobra.Command, error) {
  cobra.OnInitialize(initViperConfigs)

  // Use executable name as the command name
  rootCmd := &cobra.Command{
    Use: exeName,
  }
  {{/*note: viper binded flag value must be retrieved from viper rather than cmd*/}}
  // register basic flags
  rootCmd.PersistentFlags().String("hostname", client.DefaultHost, "hostname of the service")
  if err := viper.BindPFlag("hostname", rootCmd.PersistentFlags().Lookup("hostname")) ; err != nil {
    return nil, err
  }
  rootCmd.PersistentFlags().String("scheme", client.DefaultSchemes[0], fmt.Sprintf("Choose from: %v", client.DefaultSchemes))
  if err := viper.BindPFlag("scheme", rootCmd.PersistentFlags().Lookup("scheme")) ; err != nil {
    return nil, err
  }
  rootCmd.PersistentFlags().String("base-path", client.DefaultBasePath, fmt.Sprintf("For example: %v", client.DefaultBasePath))
  if err := viper.BindPFlag("base_path", rootCmd.PersistentFlags().Lookup("base-path")) ; err != nil {
    return nil, err
  }

  // configure debug flag
  rootCmd.PersistentFlags().BoolVar(&debug, "debug", false, "output debug logs")
  // configure config location
  rootCmd.PersistentFlags().StringVar(&configFile, "config", "", "config file path")
  // configure dry run flag
  rootCmd.PersistentFlags().BoolVar(&dryRun, "dry-run", false, "do not send the request to server")

  // register security flags
  {{- if .SecurityDefinitions }}
  if err := registerAuthInoWriterFlags(rootCmd); err != nil{
    return nil, err
  }
  {{- end }}

  // add all operation groups
{{- range $index,$element := .OperationGroups }}
  c{{ $index }}, err := make{{ cmdGroupName $element }}()
  if err != nil {
    return nil, err
  }
  rootCmd.AddCommand(c{{ $index}})
{{- end }}

  // add cobra completion
  rootCmd.AddCommand(makeGenCompletionCmd())

  return rootCmd, nil
}

// initViperConfigs initialize viper config using config file in '$HOME/.config/<cli name>/config.<json|yaml...>'
// currently hostname, scheme and auth tokens can be specified in this config file.
func initViperConfigs() {
  if configFile != "" {
    // use user specified config file location
    viper.SetConfigFile(configFile)
  } else{
    var (
      configDir string
      err error
    )

    // look for default config (OS-specific, e.g. ".config" on linux)
    configDir, err = os.UserConfigDir()
    if err != nil {
      // fallback and try finding the home directory.
      home, err := os.UserHomeDir()
      cobra.CheckErr(err)
      configDir = path.Join(home, ".config")
    }

    // Search config in the config directory with name of the CLI binary (without extension).
    configDir = path.Join(configDir, exeName)
    viper.AddConfigPath(configDir)
    viper.SetConfigName("config")
  }

  if err := viper.ReadInConfig(); err != nil {
    logDebugf("Error: loading config file: %v", err)
    return
  }
  logDebugf("Using config file: %v", viper.ConfigFileUsed())
}

{{- if .SecurityDefinitions }}
{{- /*youyuan: rework this since spec may define multiple auth schemes.
  cli needs to detect which one user passed rather than add all of them.*/}}

// registerAuthInoWriterFlags registers all flags needed to perform authentication
func registerAuthInoWriterFlags(cmd *cobra.Command) error {
{{- range .SecurityDefinitions }}
  // {{.Name}}
  {{- if .Description }}
    {{- comment .Description }}
  {{- end }}
  {{- if .IsBasicAuth }}
  cmd.PersistentFlags().String("username", "", "username for basic auth")
  if err := viper.BindPFlag("username", cmd.PersistentFlags().Lookup("username")) ; err != nil {
    return err
  }
  cmd.PersistentFlags().String("password", "", "password for basic auth")
  if err := viper.BindPFlag("password", cmd.PersistentFlags().Lookup("password")) ; err != nil {
    return err
  }
  {{- end }}
  {{- if .IsAPIKeyAuth }}
  cmd.PersistentFlags().String("{{.Name}}", "", `{{.Description}}`)
  if err := viper.BindPFlag("{{.Name}}", cmd.PersistentFlags().Lookup("{{.Name}}")) ; err != nil {
    return err
  }
  {{- end }}
  {{- if .IsOAuth2 }}
  // oauth2: let user provide the token in a flag, rather than implement the logic to fetch the token.
  cmd.PersistentFlags().String("oauth2-token", "", `{{.Description}}`)
  if err := viper.BindPFlag("oauth2-token", cmd.PersistentFlags().Lookup("oauth2-token")) ; err != nil {
    return err
  }
  {{- end }}
{{ end }}

  return nil
}

// makeAuthInfoWriter retrieves cmd flags and construct an auth info writer
func makeAuthInfoWriter(cmd *cobra.Command) (runtime.ClientAuthInfoWriter, error) {
  auths := []runtime.ClientAuthInfoWriter{}
{{- range .SecurityDefinitions }}

  // {{.Name}}
  {{- if .Description }}
    {{- comment .Description }}
  {{- end }}
  {{- if .IsBasicAuth }}
  if viper.IsSet("username") {
    usr := viper.GetString("username")
    if !viper.IsSet("password"){
      return nil, fmt.Errorf("Basic Auth password for user [%v] is not provided.", usr)
    }
    pwd := viper.GetString("password")
    auths = append(auths, httptransport.BasicAuth(usr,pwd))
  }
  {{- end }}
  {{- if .IsAPIKeyAuth }}
  if viper.IsSet("{{.Name}}") {
    {{ pascalize .Name }}Key := viper.GetString("{{.Name}}")
    auths = append(auths, httptransport.APIKeyAuth("{{.Name}}", "{{.In}}", {{ pascalize .Name }}Key))
  }
  {{- end }}
  {{- if .IsOAuth2 }}
  if viper.IsSet("oauth2-token") {
    // oauth2 workflow for generated CLI is not ideal.
    // If you have suggestions on how to support it, raise an issue here: https://github.com/go-swagger/go-swagger/issues
    // This will be added to header: "Authorization: Bearer {oauth2-token value}"
    token := viper.GetString("oauth2-token")
    auths = append(auths, httptransport.BearerToken(token))
  }
  {{- end }}
{{- end }}

  if len(auths) == 0 {
    logDebugf("Warning: No auth params detected.")
    return nil, nil
  }

  // compose all auths together
  return httptransport.Compose(auths...), nil
}
{{- end }}

{{- range .OperationGroups -}}

// make{{ cmdGroupName . }} returns a parent command to handle all operations with tag {{ printf "%q" .Name }}
func make{{ cmdGroupName . }}() (*cobra.Command, error) {
  parent := &cobra.Command{
  Use:   "{{ .Name }}",
  Long:  `{{ .Description }}`,
  }

  {{- range $index,$element := .Operations }}

  sub{{ $index }}, err := make{{ cmdName $element }}()
  if err != nil {
    return nil, err
  }
  parent.AddCommand(sub{{ $index }})
  {{- end }}

  return parent, nil
}
{{- end }} {{/*operation group*/}}
