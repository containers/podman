# -*- sh -*-
#
# test more container-related endpoints
#

podman pull "${IMAGE}" &>/dev/null

# Ensure clean slate
podman rm -a -f &>/dev/null

CTR="WaitTestingCtr"

t POST "containers/nonExistent/wait?condition=next-exit" 404

# Make sure to test a non-zero exit code (see #18889)
podman create --name "${CTR}" "${IMAGE}" sh -c "exit 3"

t POST "containers/${CTR}/wait?condition=non-existent-cond" 400

t POST "containers/${CTR}/wait?condition=not-running" 200

# Test waiting for EXIT (need to start a background trigger first)
(sleep 2;podman start "${CTR}") &
child_pid=$!

# This will block until the background job completes
t POST "containers/${CTR}/wait?condition=next-exit" 200 \
  .StatusCode=3 \
  .Error=null
wait "${child_pid}"

# Test that headers are sent before body. (We should actually never get a body)
APIV2_TEST_EXPECT_TIMEOUT=2 t POST "containers/${CTR}/wait?condition=next-exit" 999
like "$(<$WORKDIR/curl.headers.out)" ".*HTTP.* 200 OK.*" \
     "Received headers from /wait"
if [[ -e $WORKDIR/curl.result.out ]]; then
    _show_ok 0 "UNEXPECTED: curl on /wait returned results"
fi

# Test waiting for REMOVE. Like above, start a background trigger.
(sleep 2;podman container rm "${CTR}") &
child_pid=$!

t POST "containers/${CTR}/wait?condition=removed" 200 \
  .StatusCode=3 \
  .Error=null
# Make sure the container has really been removed after waiting for
# "condition=removed". This check is racy but should flake in case it doesn't
# work correctly.
t POST "containers/${CTR}/wait?condition=next-exit" 404
wait "${child_pid}"
